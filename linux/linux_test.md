Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。

虽然 Linux 和 UNIX 的每个版本中都包含 test 命令，但该命令有一个更常用的别名 — 左方括号：[。test 及其别名通常都可以在 /usr/bin 或 /bin （取决于操作系统版本和供应商）中找到。

当您使用左方括号而非 test 时，其后**必须**始终跟着一个空格、要评估的条件、一个空格和右方括号。右方括号不是任何东西的别名，而是表示所需评估参数的结束。条件两边的空格是必需的，这表示要调用 test，以区别于同样经常使用方括号的字符/模式匹配操作。

test 和 [ 的语法如下：

　　`test expression`

　　`[ expression ]`

## 数值测试

 * `-eq`	：等于则为真

 * `-ne`	：不等于则为真

 * `-gt`	：大于则为真

 * `-ge`	：大于等于则为真

 * `-lt`	：小于则为真

 * `-le`	：小于等于则为真

例子：
```
num1=100
num2=100
if [ $num1 -eq $num2 ]
then
    echo '两个数相等！'
else
    echo '两个数不相等！'
fi
```
输出：
```
两个数相等！
```

## 字符串测试

 * `=`	：等于则为真

 * `!=`	：不相等则为真

 * `-z 字符串`	：字符串的长度为零则为真

 * `-n 字符串`	：字符串的长度不为零则为真

> -z、-n判断传入参数时需注意，见[文档](para_if.md)

例子：
```
num1="ru1noob"
num2="runoob"
if [ $num1 = $num2 ]
then
    echo '两个字符串相等!'
else
    echo '两个字符串不相等!'
fi
```
输出：
```
两个字符串不相等!
```

## 文件测试

 * `-e 文件名`	：如果文件存在则为真
 * `-r 文件名`	：如果文件存在且可读则为真
 * `-w 文件名`	：如果文件存在且可写则为真
 * `-x 文件名`	：如果文件存在且可执行则为真
 * `-s 文件名`	：如果文件存在且至少有一个字符则为真
 * `-d 文件名`	：如果文件存在且为目录则为真
 * `-f 文件名`	：如果文件存在且为普通文件则为真
 * `-c 文件名`	：如果文件存在且为字符型特殊文件则为真
 * `-b 文件名`	：如果文件存在且为块特殊文件则为真

例子：
```
cd /bin
if test -e ./bash
then
    echo '文件已存在!'
else
    echo '文件不存在!'
fi
```
输出：
```
文件已存在!
```

## 逻辑操作符

另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为："!"最高，"-a"次之，"-o"最低

&& 逻辑的 AND 的意思

|| 逻辑的 OR 的意思

`if [ $a -ne 1] && [ $a != 2 ]`或者`if [ $a -ne 1 -a $a != 2 ]`

## [[]]判断

[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。    
**支持字符串的模式匹配**，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。    
**使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。**比如可以直接使用if [[ $a != 1 && $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] && [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。    
bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。
